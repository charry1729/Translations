# 账本

**受众**：架构师、应用程序开发者和智能合约开发者、管理员

**账本**是 Hyperledger Fabric 中的一个重要概念，它存储有关业务对象的重要信息，包括对象属性的当前值和产生这些当前值的交易的历史。

在这个主题中，我们将涉及：

* [什么是账本?](#what-is-a-ledger?)
* [业务对象的实际存储](#ledgers-facts-and-states)
* [区块链账本](#a-blockchain-ledger)
* [世界状态](#world-state)
* [区块链数据结构](#blockchain)
* [区块链如何存储区块](#blocks)
* [交易](#transactions)
* [世界状态数据库选择](#world-state-database-options)
* [Fabcar 示例账本](#example-ledger-fabcar)
* [账本和命名空间](#namespaces)
* [账本和通道](#channels)

## 什么是账本？

账本包含业务的当前状态，就像一个交易日记。欧洲和中国最早的账本可以追溯到近 1000 年前，苏美尔人在 4000 年前就有了[石制账本](http://www.sciencephoto.com/media/686227/view/accounting-ledger-sumerian-cuneiform)，但让我们从一个更现代的例子开始吧！

你可能已经习惯查看你的银行账户了。对你来说，最重要的是可用的余额，它是你现在能花多少钱。如果你想看看你的余额是如何产生出来的，那么你可以查看收入和支出的交易记录。这是现实生活中的一个账本的示例——一个状态（您的银行余额）和一组确定账本的有序交易（收入和支出）。Hyperledger Fabric 同样是基于这两个问题而产生的，它显示一组账本状态的当前值，以及记录决定这些状态的交易历史。

## 账本、事实和状态

账本并不真正地存储业务对象，而是存储关于这些对象的**事实**。当我们说“我们在账本中存储一个业务对象”时，我们真正的意思是我们正在记录关于一个对象当前状态的事实，以及关于导致当前状态的交易历史的事实。在一个日益数字化的世界里，我们感觉自己在看一个物体，而不是关于一个物体的事实。对于数字对象，它很可能存在于外部数据存储中；我们存储在账本中的事实使我们能够确定它的位置以及有关它的其他关键信息。

虽然关于业务对象当前状态的事实可能会改变，但是关于它的事实的历史是**不可变的**，可以将其添加到其中，但不能对其进行回溯性更改。我们将看到，将区块链看作业务对象事实的不可变历史，是理解它的一种简单而有效的方法。

现在让我们仔细看看 Hyperledger Fabric 的账本结构！

## 账本

在 Hyperledger Fabric 中，账本由两个不同但相关的部分组成：一个世界状态和一个区块链。每一个都表示一组关于一组业务对象的事实。

首先，有一个**世界状态**，它是一个数据库，包含了一组账本状态的**当前值**的缓存。世界状态使程序可以很容易地直接访问状态的当前值，而不必遍历整个交易日志来计算它。默认情况下，账本状态表示为**键值对**，稍后我们将看到 Hyperledger Fabric 如何在这方面提供灵活性。世界状态可以频繁地更改，因为状态可以被创建、更新和删除。

其次，还有一个**区块链**，它记录改变当前世界状态的所有交易日志。交易收集在附加到区块链的区块中，以便了解导致当前世界状态的更改的历史。区块链数据结构与世界状态非常不同，因为一旦写入，就无法修改，它是**不可篡改的**。

![ledger.ledger](./ledger.diagram.1.png) 

*账本 L 包括区块链 B 和世界状态 W，世界状态 W 由区块链 B 决定。我们也可以说世界状态 W 继承自区块链 B。*

在一个 Hyperledger Fabric 网络中**逻辑**账本很有用。实际上，该网络通过**共识**维护一个账本的多个副本，这些副本与其他副本保持一致。**分布式账本技术**（DLT）这个术语经常与这种账本联系在一起，这种账本在逻辑上是单一的，但是在整个网络中分布着许多一致的副本。

现在让我们更详细地研究世界状态和区块链数据结构。

## 世界状态

世界状态将业务对象属性的当前值保存为唯一的账本状态。这很有用，因为程序通常需要对象的当前值，遍历整个区块链来计算对象的当前值会很麻烦，您可以直接从世界状态获取它。

![ledger.worldstate](./ledger.diagram.3.png) 

*一个账本世界状态包含两个状态。第一个状态是： key=CAR1 和 value=Audi。第二个状态有一个更复杂的值：key=CAR2 和 value={model:BMW, color=red, owner=Jane} 。两个状态的版本都是0。*

账本状态记录一组关于特定业务对象的事实。我们的示例显示了 CAR1 和 CAR2 这两辆车的账本状态，每辆车都有一个键和一个值。应用程序可以调用智能合约，该合约使用简单的账本 API 来**获取**、**设置**和**删除**状态。注意状态值可以简单值（Audi...），也可以是复合值（type:BMW...）。通常通过查询世界状态来检索具有特定属性的对象，例如查找所有红色宝马。

世界状态用数据库实现。这很有意义，因为数据库提供了一组丰富的操作符来有效地存储和检索状态。稍后我们将看到，可以将 Hyperledger Fabric 配置为使用不同的世界状态数据库来满足不同类型的状态值和应用程序所需的访问模式的需要，例如，复杂查询。

应用程序提交更改世界状态的交易，这些交易最终提交到账本区块链。应用程序通过 Hyperledger Fabric SDK 与这种[共识机制](../txflow.html)的细节隔离，它们仅仅调用一个智能合约，当交易被包含在区块链中时（无论是否有效），它们都会被通知。重点是，只有被**背书组织签名**的交易才会导致对世界状态的更新。如果一个交易没有足够的背书者签名，它将不会导致世界状态的改变。您可以阅读更多关于应用程序如何使用[智能合约](../smartcontract/smartcontract.html)以及如何[开发应用程序](../developapps/developing_applications.html)的信息。

您还会注意到，状态有一个版本号，在上面的图表中，状态 CAR1 和 CAR2 处于它们的初始版本 0。版本号用于 Hyperledger Fabric 内部，并在每次状态更改时递增。每当更新状态时，都会检查版本，以确保当前状态与背书时的版本匹配。这就确保了世界状态正在按照预期发生变化，没有被更新。

最后，当第一次创建账本时，世界状态为空。因为任何对世界状态有效更改的交易都记录在区块链上，这意味着可以随时从区块链重新生成世界状态。这非常方便，例如，创建节点时自动生成世界状态。此外，如果某个节点发生异常，则可以在节点重新启动后，接受交易之前，重新生成世界状态。

## 区块链

现在让我们把注意力从世界状态转移到区块链。虽然世界状态包含一组与一组业务对象的当前状态相关的事实，但是区块链是关于这些对象如何达到当前状态的事实的历史记录。区块链记录了每个账本状态的每个历史版本以及它是如何被更改的。

区块链结构为相互链接的区块的顺序日志，其中每个区块包含一系列交易，每个交易表示对世界状态的查询或更新。[其他地方](../peers/peers.html#peers-and-orderers)讨论了交易的确切排序机制，重要的是，区块排序，以及区块内的交易排序，是在称为**排序服务**的 Hyperledger Fabric 组件首次创建区块时建立的。

每个区块的头部都包含区块交易的哈希，以及前一个区块头哈希的副本。这样，账本上的所有交易都按顺序排列，并以密码方式连接在一起。这种哈希和链接使账本数据非常安全。即使一个保存账本的节点被篡改了，它也不能让所有其他节点相信它拥有“正确的”区块链，因为账本分布在一个由独立节点组成的网络中。

与使用数据库的世界状态不同，区块链以文件方式实现。这是一个明智的设计，因为区块链数据结构主要偏向于非常小的一组简单操作。附加到区块链末尾的操作是主要操作，查询目前是一个相对不频繁的操作。

让我们更详细地看看区块链的结构。

![ledger.blockchain](./ledger.diagram.2.png) 

*区块链 B 包含区块 B0、B1、B2、B3。B0 是它的第一个区块，也就是初始区块。*

在上面的图中，我们可以看到**区块** B2 有一个**区块数据** D2，它包含所有的交易：T5、T6、T7。

最重要的是，B2 有一个**区块头** H2，它包含 D2 中所有交易的加密**哈希**，以及与前一个区块 B1 相同的哈希。通过这种方式，区块之间不可分割地、不可改变地链接在一起，术语**区块链**很好地描述了这一点！

最后，如图所示，区块链中的第一个区块称为**初始区块**。它是账本的起点，尽管它不包含任何用户交易。相反，它包含一个配置交易，其中包含网络通道的初始状态（未显示）。在讨论区块链网络和[通道](../channels.html) 时，我们将更详细地讨论初始区块。

## 区块

让我们仔细看看一个区块的结构。它由三个部分组成

* **区块头**

  这个部分包含三个字段，这些字段在创建一个区块时候被写入。

  * **区块编号**：一个从0开始 （初始区块）的数字，每一个附加到区块链上的新区块的编号都会加1。

  * **当前区块的哈希值**：当前区块中包含的所有交易的哈希值。

  * **前一区块的哈希值**：区块链中前一个区块的哈希值。

  这些字段是在内部通过对块数据进行哈希而生成的。它们确保了每一个区块不可分割地和它的相邻区块相连，从而组成一个不可更改的账本。

  ![ledger.blocks](./ledger.diagram.4.png) 
  
  *区块头详情：区块 B2 的区块头 H2 包含了区块编号2，当前区块数据 D2 的哈希值 CH2，和前一个区块的哈希值 PH1，区块编号1。*

* **区块数据**

  这部分包含了一个有序的交易列表。它是在排序服务创建区块时写入的。这些交易具有一个复杂但是很直接的结构，我们会在[后边](#Transactions)讲解。


* **区块元数据**

  这个部分包含了区块被写入的时间，还有证书、公钥以及区块写入者的签名。接下来，区块的提交者也会为每一笔交易添加一个有效或无效的标记，但是这个信息是不会包含进哈希值的，因为它是在区块创建之后产生的。

## 交易

正如我们所看到的，一笔交易记录了对于世界状态的变更。让我们来看一下区块中交易的详细**区块数据**结构。


![ledger.transaction](./ledger.diagram.5.png)

*易详情：区块 B1 的区块数据 D1 中的交易 T4 包括了交易头 H4，一个交易签名 S4，一个交易提案 P4，一个交易的响应和一个背书的列表 E4。*

在上面的例子中，我们可以看到以下字段：

* **Header**

  这部分用 H4 表示，记录了关于交易的一些重要的元数据，比如，相关链码的名字以及它的版本。

* **Signature**

  这部分用 S4 表示，包含了一个由客户端应用程序创建的经过加密的签名。这个字段被用来检查交易的详细内容是否被篡改过，因为这个签名需要应用程序的私钥来生成。

* **Proposal**

  这部分用 P4 表示，包含了一个应用程序提供给智能合约的输入参数，这个智能合约创建了这个对账本的更新。当链码执行的时候，这个提案提供了一套输入参数，这些参数同当前的世界状态一起决定了新的世界状态。

* **Response**

  这部分用 R4 表示，其中的**读写集** （RW-set）记录了之前和之后世界状态的值。它是一个智能合约的输出，并且如果交易验证过的话，它会被应用到账本上以更新世界状态。

* **Endorsements**

  就像 E4 显示的那样，这是一个满足背书策略的经过签名的交易响应列表。你会注意到，在交易中只包含一个交易响应，但是会有多个背书。这是因为每个背书包含了它的组织特定的交易响应，这意味着不需要包含任何没有有效的背书的交易响应，因为它会被作为无效的交易被拒绝，并且不会更新世界状态。

这总结了交易的主要字段，还有其他字段，但是这些是您需要了解的基本字段，以便于对账本数据结构有一个很好的了解。

## 世界状态数据库选项

世界状态在物理上是以一个数据库的形式实现的，提供了简单有效的对于账本状态的存储和检索。正如我们所看到的，账本状态可以有简单值，也可以有复合值，为了适应这一点，世界状态数据库可以是不同的，从而允许这些值得到有效的实现。目前，世界状态数据库的选项包括 LevelDB 和 CouchDB 。

LevelDB 是默认值，当账本状态是简单的键值对时，它很适用。LevelDB 数据库与网络节点紧密地共存，它被嵌入在相同的操作系统进程中。

当账本状态结构为 JSON 文档时，CouchDB 是一个比较合适的选择，因为 CouchDB 支持在业务交易中经常看到的富查询和更新数据类型。在实现方面，CouchDB 运行在单独的操作系统进程中，但是节点和 CouchDB 实例之间仍然存在1:1的关系。所有这些都是智能合约所看不到的。有关 CouchDB 的更多信息，请参见 [CouchDB 作为状态数据库](../couchdb_as_state_database.html)。

在 LevelDB 和 CouchDB 中，我们看到了 Hyperledger Fabric 的一个重要方面——它是*可插拔*的。世界状态数据库可以是关系数据存储、图形存储或时态数据库。这为可以有效访问的账本状态类型提供了极大的灵活性，允许 Hyperledger Fabric 处理不同类型的问题。

## 示例账本：fabcar

当我们结束关于账本的话题时，让我们来看一个示例账本。如果您已经运行了 [fabcar 示例应用程序](../write_first_app.html)，那么您就已经创建了这个账本。

fabcar 示例应用程序创建了 10 辆车，每辆车都有一个唯一的标识；有不同的颜色，制造商，型号和拥有者。以下是前四辆车创建后的账本。

![ledger.transaction](./ledger.diagram.6.png) 

*这个账本 L，包含了一个世界状态 W 和一个区块链 B。W 包含了四个键：CAR0，CAR1，CAR2 和 CAR3 的状态。B 包含两个区块0和1。区块1包含了四笔交易：T1，T2，T3，T4。*

我们可以看到世界状态包含了对应于 CAR0、CAR1、CAR2 和 CAR3 的状态。CAR0 的值表明这是一辆蓝色的丰田普锐斯（Toyota Prius），目前归 Tomoko 所有，我们可以看到其他车的状态和值类似。此外，我们可以看到所有车辆状态的版本号都是0，这表示这是它们的初始版本号自创建以来，它们一直没有被更新过。

我们还可以看到区块链包含两个区块。区块0是创世区块，尽管它不包含任何与汽车相关的交易。区块1包含交易 T1、T2、T3、T4，这些交易对应于为世界状态中的 CAR0 到 CAR3 创建初始状态的交易。我们可以看到区块1与区块0是相连的。

我们还没有显示区块或交易中的其他字段，特别是头部和哈希值。如果您对这些细节感兴趣，可以在文档的其他地方找到专门的参考主题。它为您提供了一个完整的工作示例，其中详细介绍了整个区块及其交易，但是现在，您已经对 Hyperledger Fabric 账本有了很好的概念上的理解了。做的很棒！

## 命名空间

虽然我们把账本描述成一个单一的世界状态和单一的区块链，但这有点过于简单化了。实际上，每个链码都有自己的世界状态，与所有其他链码分离。世界状态位于一个名称空间中，因此只有同一链码中的智能合约才能访问给定的名称空间。

区块链没有名称空间。它包含来自许多不同智能合约名称空间的交易。您可以在此[主题](./developapps/chaincodenamespace.html)中阅读更多关于链码名称空间的信息。

现在让我们看看名称空间的概念是如何应用于 Hyperledger Fabric 通道中的。

## 通道

在 Hyperledger Fabric 中，每个[通道](../channels.html)都有一个完全独立的账本。这意味着完全独立的区块链和完全独立的世界状态，包括名称空间。应用程序和智能合约可以在通道之间通信，以便在通道之间访问账本信息。

在本[主题](./developapps/chaincodenamespace.html#channel)中，您可以阅读更多关于账本如何与通道一起工作的信息。


## 更多信息

要深入了解交易流程、并发控制和世界状态数据库，请查阅[交易流程](../txflow.html)、[读写集语义](../readwrite.html)和 [CouchDB 作为状态数据库](../couchdb_as_state_database.html)主题。

<!--- Licensed under Creative Commons Attribution 4.0 International License
https://creativecommons.org/licenses/by/4.0/ -->
