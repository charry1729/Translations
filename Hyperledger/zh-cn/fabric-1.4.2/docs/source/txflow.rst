交易流程
================

本文讲解在一个标准的资产交换中的交易机制。该场景包含两个客户端 A 和 B，他们分别代表萝卜的买方和卖方。他们在网络上都有一个 Peer 节点，他们通过该节点来发送交易和与账本交互。

.. image:: images/step0.png

**假设**

该流程中，假设已经设置了一个通道，并且该通道正常运行。应用程序的用户已经使用组织的 CA 注册和登记完成，并且拿到了用于在网络中用确认身份的加密材料。

链码（包含了萝卜商店初始状态的键值对）已经在 Peer 节点上安装并在通道上完成了实例化。链码中的逻辑定义了萝卜的交易和定价规则。链码也设置了一个背书策略，该策略是每一笔交易都必须被 ``peerA`` 和 ``peerB`` 都签名。

.. image:: images/step1.png

1. **客户端启动一笔交易**

将会发生什么？客户端 A 发送一个采购萝卜的请求。该请求会到达 ``peerA`` 和 ``peerB``，他们分别代表客户端 A 和客户端 B。背书策略要求所有交易都要两个节点背书，因此请求要到经过 ``peerA`` 和 ``peerB``。

然后，要构建一个交易提案。应用程序使用所支持的 SDK（Node，Java，Python）中的 API 生成一个交易提案。提案是带有确定输入参数的调用链码方法的请求，该请求的作用可能是读取或者更新账本。

SDK 的作用是将交易提案打包成合适的格式（gRPC 使用的 protocol buffer）以及根据用户的密钥对交易提案生成签名。

.. image:: images/step2.png

2. **背书节点验证签名并执行交易**

The endorsing peers verify (1) that the transaction proposal is well formed, (2)
it has not been submitted already in the past (replay-attack protection), (3)
the signature is valid (using the MSP), and (4) that the submitter (Client A, in the
example) is properly authorized to perform the proposed operation on that
channel (namely, each endorsing peer ensures that the submitter satisfies the
channel's *Writers* policy). The endorsing peers take the transaction proposal
inputs as arguments to the invoked chaincode's function. The chaincode is then
executed against the current state database to produce transaction results
including a response value, read set, and write set (i.e. key/value pairs
representing an asset to create or update). No updates are made to the
ledger at this point. The set of these values, along with the endorsing peer’s
signature is passed back as a “proposal response” to the SDK which parses the
payload for the application to consume.

.. note:: The MSP is a peer component that allows peers to verify transaction
          requests arriving from clients and to sign transaction results
          (endorsements). The writing policy is defined at channel creation time
          and determines which users are entitled to submit a transaction to
          that channel. For more information about membership, check out our
          :doc:`membership/membership` documentation.

.. image:: images/step3.png

3. **Proposal responses are inspected**

The application verifies the endorsing peer signatures and compares the proposal
responses to determine if the proposal responses are the same. If the chaincode
is only queried the ledger, the application would inspect the query response and
would typically not submit the transaction to the ordering service. If the client
application intends to submit the transaction to the ordering service to update the
ledger, the application determines if the specified endorsement policy has been
fulfilled before submitting (i.e. did peerA and peerB both endorse). The
architecture is such that even if an application chooses not to inspect
responses or otherwise forwards an unendorsed transaction, the endorsement
policy will still be enforced by peers and upheld at the commit validation
phase.

.. image:: images/step4.png

4. **Client assembles endorsements into a transaction**

The application “broadcasts” the transaction proposal and response within a
“transaction message” to the ordering service. The transaction will contain the
read/write sets, the endorsing peers signatures and the Channel ID. The
ordering service does not need to inspect the entire content of a transaction in
order to perform its operation, it simply receives transactions from all
channels in the network, orders them chronologically by channel, and creates
blocks of transactions per channel.

.. image:: images/step5.png

5. **Transaction is validated and committed**

The blocks of transactions are “delivered” to all peers on the channel.  The
transactions within the block are validated to ensure endorsement policy is
fulfilled and to ensure that there have been no changes to ledger state for read
set variables since the read set was generated by the transaction execution.
Transactions in the block are tagged as being valid or invalid.

.. image:: images/step6.png

6. **Ledger updated**

Each peer appends the block to the channel’s chain, and for each valid
transaction the write sets are committed to current state database. An event is
emitted, to notify the client application that the transaction (invocation) has
been immutably appended to the chain, as well as notification of whether the
transaction was validated or invalidated.

.. note:: Applications should listen for the transaction event after submitting
          a transaction, for example by using the ``submitTransaction``
          API, which automatically listen for transaction events. Without
          listening for transaction events, you will not know
          whether your transaction has actually been ordered, validated, and
          committed to the ledger.

See the :ref:`sequence diagram <swimlane>` to better understand the
transaction flow.

.. Licensed under Creative Commons Attribution 4.0 International License
https://creativecommons.org/licenses/by/4.0/
