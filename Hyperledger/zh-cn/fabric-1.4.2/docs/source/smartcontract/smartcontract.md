# 智能合约和链码

**受众** ：架构师、应用程序和智能合约开发者、管理员。

从应用程序开发人员的角度来看，**智能合约**与[账本](../ledger/ledger.html)一起构成了 Hyperledger Fabric 区块链系统的核心。账本包含关于一组业务对象的当前和历史状态的事实，而**智能合约**定义了生成添加到账本中的新事实的可执行逻辑。链码通常被管理员用于对相关的智能合约进行分组，以便部署，但也可以用于Fabric的低级系统编程。在本主题中，我们将重点讨论为什么**智能合约**和**链码**都存在，以及如何和何时使用它们。

在本主题中，我们将讨论：

* [什么是智能合约](#smart-contract)
* [术语说明](#terminology)
* [智能合约和账本](#ledger)
* [怎么开发一个智能合约](#developing)
* [背书策略的重要性](#endorsement)
* [验证交易](#valid-transactions)
* [智能合约和通道](#channels)
* [智能合约之间的通信](#intercommunication)
* [什么是系统链码](#system-chaincode)

## 智能合约

在业务之间进行交互之前，它们必须定义一组公共合约，其中包括公共术语、数据、规则、概念定义和流程。将这些合约放在一起，就构成了管理交易各方之间所有交互的**业务模型**。

![smart.diagram1](./smartcontract.diagram.01.png) 

*智能合约在可执行的代码中定义了不同组织之间的规则。应用程序调用智能合约来生成记录到账本上的交易。*

通过使用区块链网络，我们可以将这些合约转换为可执行程序（业内称为**智能合约**），从而打开各种各样的新可能性。这是因为智能合约可以为**任何**类型的业务对象实现治理规则，以便在执行智能合约时自动执行这些规则。例如，一个智能合约可能会确保新车在指定的时间内交付，或者根据预先安排的条款释放资金，分别改善货物或资本的流动。然而最重要的是，智能合约的执行要比人工业务流程高效得多。

在上面的[图](#smart-contract)中，我们可以看到两个组织，`ORG1` 和 `ORG2`，如何定义了一个汽车智能合约来`查询`、`流转`和`更新`汽车。来自这些组织的应用程序调用此智能合约来执行业务流程中商定的步骤，例如将特定汽车的所有权从 `ORG1` 转移到 `ORG2`。

## 术语

Hyperledger Fabric 用户经常交替使用**智能合约**和**链码**。通常，智能合约定义**交易逻辑**，来控制包含在世界状态中的业务对象的生命周期。将其打包成链码，然后部署到区块链网络。可以将智能合约看作管理交易，而链码则控制如何打包用于部署的智能合约。

![smart.diagram2](./smartcontract.diagram.02.png) 

*一个智能合约定义在一个链码中。多个智能合约可以定义在同一个链码中。当链码部署以后，它包含的所有只能合约都可以被应用程序使用。*

在图中，我们可以看到包含三个智能合约的`车辆`链码：`汽车`、`船只`和`卡车`。我们还可以看到包含四个智能合约的`保险`链码：`保单`、`义务`、`银团`和`证券化`。在这两种情况下，这些合约涵盖了与车辆和保险相关的业务流程的关键方面。在本主题中，我们将以`汽车`约为例。我们可以看到，智能合约是一个特定领域的程序，它与特定的业务流程相关，而链码是一组用于安装和实例化的相关智能合约的技术容器。

## 账本

最简单的，区块链使更新账本状态的交易不可更改。智能合约以编程方式访问账本两个不同的部分： **区块**（不可篡改地记录者所有交易的历史）和**世界状态**（保存这些状态的当前值的缓存，它是一个对象的当前值）。

智能合约主要将状态**写入**（put）、**读取**（get）和**删除**（delete）到世界状态中，还可以查询不可篡改的区块链交易记录。

* **读取（get）** 操作，一般表示查询交易对象当前状态的信息。
* **写入（put）** 操作 ，一般表示创建或者更新一个交易对象到账本世界状态。
* **删除（delete）** 操作，表示从账本的当前状态删除一个交易对象，但是不会删除它的历史。

智能合约有许多可用的 [API](../developapps/transactioncontext.html#structure)。关键的是，在所有情况下，无论交易创建、读取、更新还是删除世界状态中的业务对象，区块链都包含了这些操作的记录，并且这些[记录也是不可更改的](../ledger/ledger.html) 。

## 开发

智能合约是应用程序开发的重点，正如我们所看到的，可以在一个链码中定义一个或多个智能合约。将链码部署到网络中，可以使其中包含的所有智能合约对该网络中的组织可用。这意味着只有管理员才需要考虑链码；其他人都只用考虑智能合约。

智能合约的核心是一组`交易`的定义。例如 [`fabcar.js`](https://github.com/hyperledger/fabric-samples/blob/master/chaincode/fabcar/javascript/lib/fabcar.js#L93)，你可以看到一个创建一辆新车的智能合约交易：

```javascript
async createCar(ctx, carNumber, make, model, color, owner) {

    const car = {
        color,
        docType: 'car',
        make,
        model,
        owner,
    };

    await ctx.stub.putState(carNumber, Buffer.from(JSON.stringify(car)));
}
```

在[编写您的第一个应用程序](../write_first_app.html) 教程中，您可以了解更多关于 **Fabcar** 智能合约的信息。

智能合约几乎可以描述所有的业务用例，只要他们与多个组织决策中数据的不可篡改相关。智能合约开发人员的工作是获取一个现有的业务流程，它们可能是可控制财务价格或交付条件，并用 JavaScript、GOLANG 或 Java 等编程语言将其表示为一个智能合约。将数百年的法律语言转换为编程语言是需要的法律和技术技能的，越来越多的**智能合约审核员**也正在实践。您可以在[开发应用程序主题](../developapps/developing_applications.html)中了解如何设计和开发智能合约。

## 背书

每个链码都有一个背书策略与之相关联，它适用于其中定义的所有智能合约。背书策略非常重要；它指示区块链网络中的哪些组织必须签署智能合约生成的交易，以便该交易被声明为**有效的**。

![smart.diagram3](./smartcontract.diagram.03.png) 

*每一个智能合约都有一个与之关联的背书策略。这个背书策略定义了在智能合约生成交易被认证为有效交易之前，哪些组织必须为其签名。*

一个示例背书策略可能会定义为：区块链网络四个组织中的三个必须在交易被认为**有效**之前签署该交易。所有的交易，无论是**有效的**还是**无效的**，都被添加到分布式账本中，但是只有**有效的**交易才会更新世界状态。

如果背书策略指定必须有多个组织签署交易，那么要想生成有效交易就必须由足够多的组织执行智能合约。在[上面](#endorsement)的示例中，要使汽车有效，需要由 `ORG1` 和 `ORG2` 执行并签署一个用于转移汽车的智能合约交易。

背书策略是 Hyperledger Fabric 不同于其他区块链的地方，比如以太坊（Ethereum）或比特币（Bitcoin）。在这些系统中，网络中的任何节点都可以生成有效的交易。Hyperledger Fabric 更真实地模拟了现实世界；交易必须由网络中可信的组织验证。例如，政府机构必须签署有效的交易`许可`，或者`购车者`和`销售者`都必须签署`汽车`转让交易。背书策略旨在让 Hyperledger Fabric 更好地为这些真实世界的交互建模。

最后，背书策略只是 Hyperledger Fabric 中[策略](../access_control.html#policies)的一个例子。还可以定义其他策略来确定谁可以查询或更新账本，或者从网络中添加或删除参与者。一般来说，策略应该由区块链网络中的组织联盟事先商定，但它们不是一成不变的。实际上，策略本身可以定义更改它们的规则。虽然这是一个高级主题，但是也可以在 Fabric 提供的规则之上[自定义背书策略](../pluggable_endorsement_and_validation.html) 。

## 验证交易

当智能合约执行时，它运行在区块链网络中组织所拥有的节点上。合约接受一组称为**交易提案**的输入参数，并将其与程序逻辑结合使用来读写账本。对世界状态的更改被捕获为**交易提案响应**（或者仅仅是**交易响应**），该响应包含一个**读写集**，其中包含已读取的状态，以及如果交易有效，将写入新的状态。注意，在执行智能合约时**世界状态没有更新**！

![smart.diagram4](./smartcontract.diagram.04.png) 

*所有的交易都有一个身份、一个提案和一个被一组组织签名的响应。所有的无论是有效的或者无效的交易都记录在区块上，但是只有有效的交易会更新世界状态。*

检查`汽车转移`交易。您可以看到一个交易 `t3`，用于 `ORG1` 和 `ORG2` 之间的汽车转移。看一下交易是如何从输入`{CAR1，ORG1，ORG2}`到输出`{CAR1.owner=ORG1，CAR1.owner=ORG2}`的，这表示汽车的所有者从 `ORG1` 变为了 `ORG2`。注意输入是如何由应用程序的组织 `ORG1` 签名的，输出是如何由背书策略标识的*两个*组织（ `ORG1` 和 ORG2 ）签名的。这些签名是使用每个参与者的私钥生成的，这意味着网络中的任何人都可以验证网络中的所有参与者在交易细节上达成了一致。

分发到网络中所有节点的交易分两个阶段进行**验证**。首先，根据背书策略检查交易，确保有足够的组织签署。其次，对其进行检查，以确保当交易由背书节点签名时，世界状态的当前值与交易的读集匹配，中间过程中没有被更新。如果一个交易通过了这两个测试，它就被标记为**有效的**。所有交易都被添加到区块链历史记录中，不管是**有效的**还是**无效的**，但是只有**有效的**交易才会更新世界状态。

在我们的示例中，`t3` 是一个有效的交易，因此 `CAR1` 的所有者已更新为 `ORG2`。但是 `t4` （未显示）是无效的交易，所以当它在账本记录时，世界状态没有更新，`CAR2` 仍然属于 `ORG2` 所有。

最后，要了解如何使用具有世界状态的智能合约或链码，请阅读[链码命名空间主题](../developapps/chaincodenamespace.html)。

## 通道

Hyperledger Fabric 允许组织通过**通道**同时参与多个单独的区块链网络。通过加入多个通道，一个组织可以参与一个所谓的**网络的网络**。通道提供高效的基础设施共享，同时维护数据和通信隐私。通道是独立的，可以帮助组织将它们的工作流量与不同的交易方分开，也是集成的，以便在必要时协调独立的活动。

![smart.diagram5](./smartcontract.diagram.05.png)

*通道在组织中提供了隔离的通信机制。当链码在通道上实例化时，就为这个链码定义了一个背书策略。在实例化了链码的通道上，链码中所有的智能合约对应用程序都是可用的。*

当链码在通道上[实例化](../endorsement-policies.html#specifying-endorsement-policies-for-a-chaincode)时，管理员为链码定义一个背书策略，并且可以在链码升级时更改它。背书策略同样适用于部署到通道的同一链码中定义的所有智能合约。这也意味着一个智能合约可以被部署到不同的通道，使用不同的背书策略。

在[上面](#channels)的示例中，将`汽车`合约部署到`车辆`通道，并将`保险`合约部署到`保险`通道。汽车合约有一个背书策略，要求 `ORG1` 和 `ORG2` 在交易被认为有效之前签署该交易，而保险合约也有一个背书策略，只要求 `ORG3` 签署有效交易。`ORG1` 参与`车辆`通道和`保险`网络两个网络，分别与 `ORG2` 和 `ORG3` 协调这两个网络之间的活动。

## 互相通信

智能合约能够调用同一通道和不同通道的其他智能合约。通过这种方式，他们可以读写世界状态数据，否则由于智能合约名称空间的约束，他们将无法访问这些数据。

这种内部合约通信有一些限制，这些限制将在[链码名称空间](../developapps/chaincodenamespace.html#cross-chaincode-access)主题中详细描述。

## 系统链码

链码中定义的智能合约编码了区块链组织之间达成一致的业务流程的相关规则。然而，链码还可以定义底层程序代码，这些代码对应独立的**系统**交互，与这些业务流程的智能合约无关。

以下是不同类型的系统链码及其相关缩写：

* 生命周期系统链码（LSCC）运行在所有 Peer 节点上，处理链码包签名，安装、实例化和升级链码的请求。你可以在[这里](../chaincode4noah.html#chaincode-lifecycle)阅读更多 LSCC 实现的内容。

* 配置系统链码（CSCC）运行在所有 Peer 节点上，用来处理通道配置的变化，比如策略升级。你可以在[这里](../configtx.html#configuration-updates)阅读更多 CSCC 实现的内容。

* 查询系统链码（QSCC）运行在所有 Peer 节点上，提供账本 API，包括区块查询、交易查询等。你可以在[交易上下文](../developapps/transactioncontext.html)主题中查阅更多这些账本 API 的信息。

* 背书系统链码（ESCC）运行在所有背书节点中，来签名交易响应。你可以在[这里](../peers/peers.html#phase-1-proposal)阅读更多 ESCC 实现的内容。

* 验证系统链码（VSCC）验证一个交易，包括检查背书策略和读写集版本。你可以在[这里](../peers/peers.html#phase-3-validation)阅读更多 VSCC 实现的内容。

底层的 Fabric 开发人员和管理员可以根据自己的需要修改这些系统链码。然而，系统链码的开发和管理是一项专门的活动，与智能合约的开发完全分离，通常没有必要。对系统链码的更改必须非常小心地处理，因为它们是 Hyperledger Fabric 网络正确运行的基础。例如，如果没有正确地开发系统链代码，一个 Peer 节点可能会以不同的方式更新其世界状态或区块链副本。这种缺乏共识是**账本分叉**的一种形式，是一种非常不可取的情况。

<!--- Licensed under Creative Commons Attribution 4.0 International License
https://creativecommons.org/licenses/by/4.0/ -->
